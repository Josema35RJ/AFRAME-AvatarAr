<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>AR Avatar — WebXR + fallback model-viewer</title>
  <style>
    body { margin:0; overflow:hidden; font-family:system-ui,Segoe UI,Roboto; background:#000; color:#fff;}
    #ui { position:absolute; left:12px; top:12px; z-index:10; background:rgba(0,0,0,0.45); padding:8px 10px; border-radius:8px;}
    button { margin:4px 6px 0 0; padding:8px 10px; border-radius:6px; border:0; background:#1e90ff; color:#fff; cursor:pointer;}
    #status { margin-top:6px; font-size:13px; color:#ffd; }
    a[slot="ar-button"] { display:none; } /* ARButton will be added to DOM */
    /* model-viewer fallback container hidden until needed */
    #mvContainer { position:absolute; right:12px; top:12px; z-index:10; }
  </style>
</head>
<body>

<div id="ui">
  <strong>Avatar AR — prueba</strong><br>
  <small>Mueve el teléfono, toca la pantalla para colocar.</small>
  <div id="status">Inicializando…</div>
  <div style="margin-top:8px;">
    <button id="btnCenter">Centrar reticle</button>
    <button id="btnReset">Reset avatar</button>
  </div>
</div>

<div id="mvContainer"></div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { ARButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/ARButton.js';

const STATUS = document.getElementById('status');
const btnCenter = document.getElementById('btnCenter');
const btnReset = document.getElementById('btnReset');
const mvContainer = document.getElementById('mvContainer');

function setStatus(t, err=false){ STATUS.textContent = t; STATUS.style.color = err? '#ff8b8b' : '#ffd'; }

// Scene & renderer
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 1000);
const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType('local');
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(2,4,2);
dir.castShadow = true;
scene.add(dir);

// ground (visual reference in non-AR or for debugging)
const groundGeo = new THREE.PlaneGeometry(50,50);
const groundMat = new THREE.MeshStandardMaterial({color:0x98bf8a});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
ground.position.y = 0;
scene.add(ground);

// reticle (ring)
const ringGeo = new THREE.RingGeometry(0.08,0.12,64);
const ringMat = new THREE.MeshBasicMaterial({color:0x00ff88, side: THREE.DoubleSide});
const reticle = new THREE.Mesh(ringGeo, ringMat);
reticle.rotation.x = -Math.PI/2;
reticle.visible = false;
scene.add(reticle);

// GLTF model container
let avatarRoot = new THREE.Group();
avatarRoot.visible = false;
scene.add(avatarRoot);

let modelBBox = null;
let scaleToApply = 1;
const desiredHeight = 1.8; // m
const distanceMargin = 1.15; // leave 15% extra space

// load model
const loader = new GLTFLoader();
setStatus('Cargando modelo…');
loader.load('https://cdn.jsdelivr.net/gh/Josema35RJ/Avatar@main/3dpea.com_Salute.glb', gltf=>{
  avatarRoot.add(gltf.scene);
  // compute bbox (unscaled)
  modelBBox = new THREE.Box3().setFromObject(gltf.scene);
  if (!modelBBox.isEmpty()){
    const modelHeight = modelBBox.max.y - modelBBox.min.y;
    scaleToApply = desiredHeight / modelHeight;
    gltf.scene.scale.setScalar(scaleToApply);
    // adjust pivot so feet touch y=0 when placed: we will offset by -bbox.min.y * scale
    setStatus('Modelo listo. Esperando AR (WebXR) o usando fallback.');
  } else {
    setStatus('Modelo cargado pero bbox vacío.', true);
  }
}, xhr=>{}, err=>{
  console.error(err);
  setStatus('Error cargando modelo (ver consola).', true);
});

// WEBXR hit-test setup
let hitTestSource = null;
let localReferenceSpace = null;
let xrSession = null;

async function initXR() {
  if (navigator.xr) {
    const supported = await navigator.xr.isSessionSupported('immersive-ar');
    if (!supported) {
      setStatus('WebXR AR no soportado en este dispositivo. Se ofrecerá fallback.', true);
      setupFallback();
      return;
    }
    const sessionInit = { requiredFeatures: ['hit-test','dom-overlay'], optionalFeatures: ['local-floor','bounded-floor','light-estimation'], domOverlay: { root: document.body } };
    try {
      xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
    } catch (err) {
      console.warn('No session', err);
      setStatus('No se pudo iniciar sesión AR (permiso o no soportado).', true);
      setupFallback();
      return;
    }

    renderer.xr.setSession(xrSession);
    // reference spaces
    const viewerSpace = await xrSession.requestReferenceSpace('viewer');
    localReferenceSpace = await xrSession.requestReferenceSpace('local-floor').catch(()=>session.requestReferenceSpace('local'));

    // request hit test source
    hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

    setStatus('WebXR activo: apunta la cámara a una superficie. Toca para colocar.');

    xrSession.addEventListener('end', ()=> {
      hitTestSource = null;
      xrSession = null;
      setStatus('Sesión AR finalizada.');
      // show fallback UI maybe
    });

    // handle select via screen tap (XR input)
    xrSession.addEventListener('select', (ev)=>{
      if (reticle.visible) {
        placeModelAt(reticle.position.clone());
      }
    });

    // enter rendering loop
    renderer.setAnimationLoop((time, frame) => {
      if (frame) {
        const refSpace = localReferenceSpace;
        const session = frame.session;
        const pose = frame.getViewerPose(refSpace);
        // hit test
        if (hitTestSource) {
          const hitResults = frame.getHitTestResults(hitTestSource);
          if (hitResults.length > 0) {
            const hit = hitResults[0];
            const hitPose = hit.getPose(refSpace);
            reticle.visible = true;
            reticle.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
            // rotate reticle to face camera roughly (optional)
            // reticle.lookAt(camera.position); // not needed; it's flat on ground
          } else {
            reticle.visible = false;
          }
        }
      }
      renderer.render(scene, camera);
    });

    // also allow normal pointer to place (tap on screen)
    renderer.domElement.addEventListener('click', (e)=>{
      if (reticle.visible) placeModelAt(reticle.position.clone());
    });

  } else {
    setStatus('navigator.xr no disponible — se aplicará fallback.', true);
    setupFallback();
  }
}

// compute minimum distance based on camera FOV so model fits in view
function computeMinDistance(modelHeightScaled) {
  // vertical FOV in radians
  const fov = camera.fov * Math.PI / 180;
  const halfView = Math.tan(fov / 2);
  // required distance so that modelHeightScaled <= 2 * D * tan(fov/2)
  // => D >= (modelHeightScaled/2) / tan(fov/2)
  const D = (modelHeightScaled / 2) / halfView;
  return D * distanceMargin;
}

// place model at world point (three.Vector3)
function placeModelAt(point) {
  if (!modelBBox) { setStatus('Modelo no listo aún.', true); return; }
  // compute scaled modelHeight
  const modelHeight = (modelBBox.max.y - modelBBox.min.y);
  const modelHeightScaled = modelHeight * scaleToApply;

  // initial Y offset so feet touch ground
  const yOffset = -modelBBox.min.y * scaleToApply; // add to ground Y

  // propose position (point is ground contact)
  const proposed = point.clone();
  proposed.y += yOffset;

  // compute camera world pos
  const camWorld = new THREE.Vector3();
  camera.getWorldPosition(camWorld);

  // distance check: ensure >= minDistance (based on FOV)
  const dist = proposed.distanceTo(camWorld);
  const minD = computeMinDistance(modelHeightScaled);
  if (dist < minD) {
    // push away along horizontal direction from camera to proposed
    const dir = proposed.clone().sub(camWorld);
    dir.y = 0;
    if (dir.length() < 0.001) {
      // fallback direction = camera forward projected on XZ
      camera.getWorldDirection(dir);
      dir.y = 0;
      dir.normalize();
    } else {
      dir.normalize();
    }
    const newPos = camWorld.clone().add(dir.multiplyScalar(minD));
    newPos.y = proposed.y; // keep on ground
    avatarRoot.position.copy(newPos);
    setStatus(`Posicionado. Ajustado a distancia mínima ${minD.toFixed(2)} m.`);
  } else {
    avatarRoot.position.copy(proposed);
    setStatus('Avatar colocado en el punto seleccionado.');
  }

  avatarRoot.visible = true;
  // orient horizontally to face camera
  const lookTarget = camWorld.clone();
  lookTarget.y = avatarRoot.position.y;
  avatarRoot.lookAt(lookTarget);
}

// fallback: model-viewer (mobile) button + message about AR.js marker option
function setupFallback() {
  // add a model-viewer button for mobile quick AR if available
  // We'll create a small model-viewer element that, when tapped, opens Scene Viewer / Quick Look
  const supportsModelViewer = true; // modern browsers
  const mv = document.createElement('div');
  mv.innerHTML = `
    <model-viewer id="mv" src="https://cdn.jsdelivr.net/gh/Josema35RJ/Avatar@main/3dpea.com_Salute.glb"
      alt="Avatar 3D" ar ar-modes="webxr scene-viewer quick-look" camera-controls style="width:240px;height:160px;border-radius:8px;overflow:hidden;">
    </model-viewer>
    <div style="font-size:13px;margin-top:6px;color:#ffd;">Si tu navegador no soporta WebXR in-page, toca aquí para ver AR nativa (Scene Viewer / Quick Look).</div>
  `;
  mvContainer.appendChild(mv);
  // lazy-load model-viewer script
  const script = document.createElement('script');
  script.type = 'module';
  script.src = 'https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js';
  document.head.appendChild(script);

  setStatus('WebXR no disponible: se muestra fallback. También puedes usar AR.js (marker) en desktop.');
}

// UI buttons
btnCenter.addEventListener('click', ()=>{
  // cast center ray and move reticle if possible (for non-XR preview)
  const ndc = new THREE.Vector2(0,0);
  const ray = new THREE.Raycaster();
  ray.setFromCamera(ndc, camera);
  const inter = ray.intersectObject(ground, true);
  if (inter.length) {
    const p = inter[0].point;
    reticle.position.copy(p);
    reticle.position.y += 0.01;
    reticle.visible = true;
    setStatus('Reticle centrado.');
  }
});
btnReset.addEventListener('click', ()=>{
  avatarRoot.visible = false;
  setStatus('Avatar reseteado. Mueve el reticle y toca para colocar.');
});

// initial camera placement for non-AR preview
camera.position.set(0,1.6,0);
renderer.render(scene, camera);

// try to init XR
setStatus('Comprobando soporte WebXR…');
initXR();

// handle resize
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
